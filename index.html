<html>

<head>
    <title>CSC5210 The Pinnacle of Puzzles</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="600"></canvas>
    <script src="three.js"></script>
    <script src="DragControls.js"></script>

    <script>
        // Create the object to represent a triangle
        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.z = 100;  // Try moving this around!
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true, alpha: true });
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        //drawing the board itself which will stay white and be a way to use Box3
        const boardgeometry = new THREE.BoxGeometry(25, 25, 0);
        const boardmaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
        const board = new THREE.Mesh(boardgeometry, boardmaterial);
        scene.add(board);

        const material = new THREE.LineBasicMaterial({ color: 0x000000 });

        //drawing vectors for the outline of the board
        const points = [];
        points.push(new THREE.Vector3(-12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, -12.5, 0));

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);


        function getRndInteger(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        // The "Frame-per-second" loop
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        // Initiate the graphical loop
        animate();

        //var pointlist = [];
        //var 
        var tl = new Float32Array([5, 5, 0]);


        var centerx = getRndInteger(-2.5, 2.5);
        var centery = getRndInteger(-2.5, 2.5);
        var lefty = getRndInteger(-12.5, 12.5);
        var topx = getRndInteger(-12.5, 12.5);
        var righty = getRndInteger(-12.5, 12.5);
        var bottomx = getRndInteger(-12.5, 12.5);



        const dotGeometry = new THREE.BufferGeometry();
        dotGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
            -12.5, 12.5, 0,
            topx, 12.5, 0,
            12.5, 12.5, 0,
            12.5, righty, 0,
            -12.5, -12.5, 0,
            bottomx, -12.5, 0,
            12.5, -12.5, 0,
            -12.5, lefty, 0,
            centerx, centery, 0]), 3));
        const dotMaterial = new THREE.PointsMaterial({ size: 1, color: 0xff0000 });
        const dot = new THREE.Points(dotGeometry, dotMaterial);
        scene.add(dot);

        /*
        var triangles = [];
        var i = 0;
        while (i < 5) {
            const baseTriangle = new THREE.BufferGeometry();

            var x1 = getRndInteger(-25, 22);
            var y1 = getRndInteger(-25, 20);
            var x2 = x1 + 3;//getRndInteger(x1 + 1, 30);
            var y2 = y1;//getRndInteger(-20, 0);
            var x3 = (x2 + x1) / 2;//getRndInteger(x1, y1) * 0.5;
            var y3 = y1 + 5;//getRndInteger(y2, 20) * 0.5;
            var z = 0;

            var vertices = new Float32Array([
                x1, y1, z,
                x2, y2, z,
                x3, y3, z,
            ]);

            baseTriangle.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            var _material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            var mesh = new THREE.Mesh(baseTriangle, _material);

            //check for intersections
            var draw = true;
            for (let j = 0; j < triangles.length; j++) {
                var checkBox = triangles[j];
                firstBB = new THREE.Box3().setFromObject(mesh);
                secondBB = new THREE.Box3().setFromObject(checkBox);
                boardBB = new THREE.Box3().setFromObject(board);
                var collision1 = firstBB.intersectsBox(secondBB);
                var collision2 = firstBB.intersectsBox(boardBB);
                if (collision1 || collision2) {
                    draw = false;
                }
            }
            // dont add the triangle if it hits any others
            if (draw) {
                scene.add(mesh);
                triangles.push(mesh);
                var helper = new THREE.BoxHelper(mesh, 0xff0000);
                helper.update();
                scene.add(helper);
                i++;
            }
        }

        var controls = new THREE.DragControls(triangles, camera, renderer.domElement);
        var color;
        controls.addEventListener('dragstart', function (event) {
            event.object.material.opacity = 0.5
        })
        controls.addEventListener('dragend', function (event) {
            event.object.material.opacity = 1
        })
        */

    </script>
</body>

</html>
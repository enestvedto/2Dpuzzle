<html>

<head>
    <title>CSC5210 The Pinnacle of Puzzles</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="600"></canvas>
    <script src="three.js"></script>
    <script src="DragControls.js"></script>

    <script>
        // Create the object to represent a triangle
        function Triangle(a, b, c) {
            // Build the vertices manually by creating arrays
            this.vertices = [
                a[0], a[1], a[2],
                b[0], b[1], b[2],
                c[0], c[1], c[2],
            ];
            // The function that actually adds the triangle geometry to the scene
            this.render = function () {
                var geometry = new THREE.BufferGeometry();
                // Set the " position " attribute accordingly
                // Note : itemSize = 3 ( second argument ) there are 3 values per vertex
                geometry.setAttribute('position',
                    new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
                rndcolor = getRandomColor()
                var material =
                    new THREE.MeshBasicMaterial({ color: rndcolor });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }
        }

        // code grabbed from https://stackoverflow.com/questions/1484506/random-color-generator
        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // function to more easily get a random number within a desired range
        function getRndInteger(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.z = 100;  // Try moving this around!
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true, alpha: true });
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        //drawing the board itself which will stay white and be a way to use Box3
        //const boardgeometry = new THREE.BoxGeometry(25, 25, 0);
        //const boardmaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
        //const board = new THREE.Mesh(boardgeometry, boardmaterial);
        //scene.add(board);

        const material = new THREE.LineBasicMaterial({ color: 0x000000 });

        //drawing vectors for the outline of the board
        const points = [];
        points.push(new THREE.Vector3(-12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, -12.5, 0));

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);

        // The "Frame-per-second" loop
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        // Initiate the graphical loop
        animate();

        var centerx = getRndInteger(-5, 5);
        var centery = getRndInteger(-5, 5);
        var lefty = getRndInteger(-10, 10);
        var topx = getRndInteger(-10, 10);
        var righty = getRndInteger(-10, 10);
        var bottomx = getRndInteger(-10, 10);

        var triangles = [];

        /*
        const dotGeometry = new THREE.BufferGeometry();
        dotGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
            -12.5, 12.5, 0,
            topx, 12.5, 0,
            12.5, 12.5, 0,
            12.5, righty, 0,
            -12.5, -12.5, 0,
            bottomx, -12.5, 0,
            12.5, -12.5, 0,
            -12.5, lefty, 0,
            centerx, centery, 0]), 3));
        const dotMaterial = new THREE.PointsMaterial({ size: 1, color: 0x000000 });
        const dot = new THREE.Points(dotGeometry, dotMaterial);
        scene.add(dot);
        */

        //this method initializes the board. you CAN NOT have less than 6 pieces per directions
        function buildBoard(numberOfPieces) {
            //make sure the number of pieces is at least 6. don't build if it isn't
            if (numberOfPieces < 6) {
                console.log('try again with at least 6 pieces');
                return;
            }

            perSide = Math.trunc(numberOfPieces / 4);
            LrTb = numberOfPieces % 4;
            sides = [perSide, perSide, perSide, perSide];
            for (i = 0; i < LrTb; i++) {
                sides[i % 4] = sides[i % 4] + 1;
            }

            _left = sides[0];
            leftPoints = [];
            _right = sides[1];
            rightPoints = [];
            _top = sides[2];
            topPoints = [];
            _bottom = sides[3];
            bottomPoints = [];

            for (var i = 0; i < _left; i++) {
                leftPoints[i] = getRndInteger(-10, 10);
            }
            for (var i = 0; i < _right; i++) {
                rightPoints[i] = getRndInteger(-10, 10);
            }
            for (var i = 0; i < _top; i++) {
                topPoints[i] = getRndInteger(-10, 10);
            }
            for (var i = 0; i < _bottom; i++) {
                bottomPoints[i] = getRndInteger(-10, 10);
            }

            allPoints = [];

        }

        buildBoard(11);

        t1 = new Triangle([-12.5, 12.5, 0], [centerx, centery, 0], [topx, 12.5, 0]);
        t1.render();
        triangles.push(t1.mesh);
        t2 = new Triangle([topx, 12.5, 0], [centerx, centery, 0], [12.5, 12.5, 0],);
        t2.render();
        triangles.push(t2.mesh);
        t3 = new Triangle([12.5, 12.5, 0], [centerx, centery, 0], [12.5, -12.5, 0],);
        t3.render();
        triangles.push(t3.mesh);
        t4 = new Triangle([12.5, -12.5, 0], [centerx, centery, 0], [bottomx, -12.5, 0],);
        t4.render();
        triangles.push(t4.mesh);
        t5 = new Triangle([bottomx, -12.5, 0], [centerx, centery, 0], [-12.5, -12.5, 0],);
        t5.render();
        triangles.push(t5.mesh);
        t6 = new Triangle([-12.5, -12.5, 0], [centerx, centery, 0], [-12.5, 12.5, 0],);
        t6.render();
        triangles.push(t6.mesh);

        for (let i = 0; i < triangles.length - 1; i++) {
            _out = triangles[i];
            for (let j = 1; j < triangles.length; j++) {
                _in = triangles[j];
                outBB = new THREE.Box3().setFromObject(_out);
                inBB = new THREE.Box3().setFromObject(_in);
                collision = outBB.intersectsBox(inBB);
                //while (collision) {
                // }
            }
        }


        var controls = new THREE.DragControls(triangles, camera, renderer.domElement);
        controls.addEventListener('dragstart', function (event) {
            event.object.material.opacity = 0.5
        })
        controls.addEventListener('dragend', function (event) {
            event.object.material.opacity = 1
        })


    </script>
</body>

</html>
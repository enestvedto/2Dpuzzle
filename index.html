<html>

<head>
    <title>CSC5210 The Pinnacle of Puzzles</title>
</head>

<body>
    <canvas id="myCanvas" width="800" height="600"></canvas>
    <script src="three.js"></script>
    <script src="DragControls.js"></script>

    <script>
        // Create the object to represent a triangle
        function colorTriangle(a, b, c) {
            // Build the vertices manually by creating arrays
            this.vertices = [
                a[0], a[1], a[2],
                b[0], b[1], b[2],
                c[0], c[1], c[2],
            ];
            // The function that actually adds the triangle geometry to the scene
            this.render = function () {
                var geometry = new THREE.BufferGeometry();
                // Set the " position " attribute accordingly
                // Note : itemSize = 3 ( second argument ) there are 3 values per vertex
                geometry.setAttribute('position',
                    new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
                rndcolor = getRandomColor()
                var material =
                    new THREE.MeshBasicMaterial({ color: rndcolor });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }
        }

        // code grabbed from https://stackoverflow.com/questions/1484506/random-color-generator
        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // function to more easily get a random number within a desired range
        function getRndInteger(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        function load() {
            window.alert("Congratulations! You have solved the puzzle...click \"ok\" to claim your reward!");
            window.open('https://www.youtube.com/watch?v=dQw4w9WgXcQ', '_blank');
        }

        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.z = 100;  // Try moving this around!
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true, alpha: true });
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        const material = new THREE.LineBasicMaterial({ color: 0x000000 });

        //drawing vectors for the outline of the board
        const points = [];
        points.push(new THREE.Vector3(-12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, -12.5, 0));

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);

        // The "Frame-per-second" loop
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        // Initiate the graphical loop
        animate();

        var centerx = getRndInteger(-5, 5);
        var centery = getRndInteger(-5, 5);

        var triangles = [];

        //this method initializes the board. you CAN NOT have less than 6 pieces per directions
        function buildBoard(numberOfPieces) {
            //make sure the number of pieces is at least 6. don't build if it isn't
            if (numberOfPieces < 6) {
                console.log('try again with at least 6 pieces');
                return;
            }

            // calculate how to divide the number of vertices generated based on the number of triangles desired
            perSide = Math.trunc(numberOfPieces / 4);
            LrTb = numberOfPieces % 4;

            sides = [perSide, perSide, perSide, perSide];
            for (i = 0; i < LrTb; i++) {
                sides[i % 4] = sides[i % 4] + 1;
            }
            _left = sides[0];
            leftPoints = [];
            _right = sides[1];
            rightPoints = [];
            _top = sides[2];
            topPoints = [];
            _bottom = sides[3];
            bottomPoints = [];

            // randomly generate the desired number of vertices on each border side
            for (var i = 0; i < _left - 1; i++) {
                leftPoints.push(getRndInteger(-10, 10));
            }
            for (var i = 0; i < _right - 1; i++) {
                rightPoints.push(getRndInteger(-10, 10));
            }
            for (var i = 0; i < _top - 1; i++) {
                topPoints.push(getRndInteger(-10, 10));
            }
            for (var i = 0; i < _bottom - 1; i++) {
                bottomPoints.push(getRndInteger(-10, 10));
            }
            // working neg to pos
            leftPoints.sort(function (a, b) { return a - b });
            // working pos to neg
            rightPoints.sort(function (a, b) { return a - b });
            rightPoints.reverse();
            // working neg to pos
            topPoints.sort(function (a, b) { return a - b });
            // working pos to neg
            bottomPoints.sort(function (a, b) { return a - b });
            bottomPoints.reverse();

            allPoints = [];

            // put all the vertices in a list to easily reference. the 3rd vertex will always be the first vertex 
            // of the next triangle, and the generated origin will always be the second for each triangle.

            //start with the bottom left corner vertex
            allPoints.push([-12.5, -12.5, 0]);
            for (var i = 0; i < leftPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([-12.5, leftPoints[i], 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([-12.5, leftPoints[i], 0]);
            }
            //remove extra vertices and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            //finish the left triangles with the top left vertex
            allPoints.push([-12.5, 12.5, 0]);


            //next do the top vertices starting with the top left vertex
            allPoints.push([-12.5, 12.5, 0]);
            for (var i = 0; i < topPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([topPoints[i], 12.5, 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([topPoints[i], 12.5, 0]);
            }
            //remove extra vertex and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            //finish the top triangles with the top right vertex
            allPoints.push([12.5, 12.5, 0]);


            // next do the right vertices starting with the top right vertex
            allPoints.push([12.5, 12.5, 0]);
            for (var i = 0; i < rightPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([12.5, rightPoints[i], 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([12.5, rightPoints[i], 0]);
            }
            //remove extra vertex and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            //finish the right triangles with the bottom right vertex
            allPoints.push([12.5, -12.5, 0]);


            // lastly do the bottom vertices starting with the bottom right vertex
            allPoints.push([12.5, -12.5, 0]);
            for (var i = 0; i < bottomPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([bottomPoints[i], -12.5, 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([bottomPoints[i], -12.5, 0]);
            }
            //remove extra vertex and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            // finish the bottom triangles with the bottom left vertex (initial starting vertex)
            allPoints.push([-12.5, -12.5, 0]);


            // turn the list of all the vertices into triangles!
            for (var i = 0; i < allPoints.length; i += 3) {
                tmpTriangle = new colorTriangle(allPoints[i], allPoints[i + 1], allPoints[i + 2]);
                tmpTriangle.render();
                triangles.push(tmpTriangle.mesh);
            }


        }

        buildBoard(6);

        for (var i = 0; i < triangles.length; i++) {
            triangles[i].translateX(getRndInteger(-20, 20));
            triangles[i].translateY(getRndInteger(-20, 20));
        }

        /*
                for (let i = 0; i < triangles.length - 1; i++) {
                    _out = triangles[i];
                    for (let j = 1; j < triangles.length; j++) {
                        _in = triangles[j];
                        outBB = new THREE.Box3().setFromObject(_out);
                        inBB = new THREE.Box3().setFromObject(_in);
                        collision = outBB.intersectsBox(inBB);
                        //while (collision) {
                        // }
                    }
                }
        */

        var pieceControls = new THREE.DragControls(triangles, camera, renderer.domElement);
        pieceControls.addEventListener('dragstart', function (event) {
            event.object.material.opacity = 0.8
        })
        pieceControls.addEventListener('dragend', function (event) {
            event.object.material.opacity = 1
            if (Math.abs(event.object.position.x) < 0.5 && Math.abs(event.object.position.y) < 0.5) {
                event.object.position.set(0, 0, 0);
                // remove the piece from the array of draggable pieces
                const index = triangles.indexOf(event.object);
                if (index > -1) { // only splice array when item is found
                    triangles.splice(index, 1); // 2nd parameter means remove one item only
                }
                // suprise for finishing the puzzle :)
                if (triangles.length == 0) {
                    load();
                }
            }

        })


    </script>
</body>

</html>
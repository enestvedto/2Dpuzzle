<html>

<head>
    <title>CSC5210 The Pinnacle of Puzzles</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="600"></canvas>
    <script src="three.js"></script>
    <script src="DragControls.js"></script>

    <script>
        // Create the object to represent a triangle
        function Triangle(a, b, c) {
            // Build the vertices manually by creating arrays
            this.vertices = [
                a[0], a[1], a[2],
                b[0], b[1], b[2],
                c[0], c[1], c[2],
            ];
            // The function that actually adds the triangle geometry to the scene
            this.render = function () {
                var geometry = new THREE.BufferGeometry();
                // Set the " position " attribute accordingly
                // Note : itemSize = 3 ( second argument ) there are 3 values per vertex
                geometry.setAttribute('position',
                    new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
                rndcolor = getRandomColor()
                var material =
                    new THREE.MeshBasicMaterial({ color: rndcolor });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }
        }

        // code grabbed from https://stackoverflow.com/questions/1484506/random-color-generator
        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // function to more easily get a random number within a desired range
        function getRndInteger(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.z = 100;  // Try moving this around!
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true, alpha: true });
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        //drawing the board itself which will stay white and be a way to use Box3
        //const boardgeometry = new THREE.BoxGeometry(25, 25, 0);
        //const boardmaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
        //const board = new THREE.Mesh(boardgeometry, boardmaterial);
        //scene.add(board);

        const material = new THREE.LineBasicMaterial({ color: 0x000000 });

        //drawing vectors for the outline of the board
        const points = [];
        points.push(new THREE.Vector3(-12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, -12.5, 0));
        points.push(new THREE.Vector3(12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, 12.5, 0));
        points.push(new THREE.Vector3(-12.5, -12.5, 0));

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);

        // The "Frame-per-second" loop
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        // Initiate the graphical loop
        animate();

        var centerx = getRndInteger(-5, 5);
        var centery = getRndInteger(-5, 5);
        var lefty = getRndInteger(-10, 10);
        var topx = getRndInteger(-10, 10);
        var righty = getRndInteger(-10, 10);
        var bottomx = getRndInteger(-10, 10);

        var triangles = [];

        /*
        const dotGeometry = new THREE.BufferGeometry();
        dotGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
            -12.5, 12.5, 0,
            topx, 12.5, 0,
            12.5, 12.5, 0,
            12.5, righty, 0,
            -12.5, -12.5, 0,
            bottomx, -12.5, 0,
            12.5, -12.5, 0,
            -12.5, lefty, 0,
            centerx, centery, 0]), 3));
        const dotMaterial = new THREE.PointsMaterial({ size: 1, color: 0x000000 });
        const dot = new THREE.Points(dotGeometry, dotMaterial);
        scene.add(dot);
        */

        //this method initializes the board. you CAN NOT have less than 6 pieces per directions
        function buildBoard(numberOfPieces) {
            //make sure the number of pieces is at least 6. don't build if it isn't
            if (numberOfPieces < 6) {
                console.log('try again with at least 6 pieces');
                return;
            }

            // calculate how to divide the number of vertices generated based on the number of triangles desired
            perSide = Math.trunc(numberOfPieces / 4);
            LrTb = numberOfPieces % 4;

            sides = [perSide, perSide, perSide, perSide];
            for (i = 0; i < LrTb; i++) {
                sides[i % 4] = sides[i % 4] + 1;
            }
            _left = sides[0];
            leftPoints = [];
            _right = sides[1];
            rightPoints = [];
            _top = sides[2];
            topPoints = [];
            _bottom = sides[3];
            bottomPoints = [];

            // randomly generate the desired number of vertices on each border side
            for (var i = 0; i < _left - 1; i++) {
                leftPoints.push(getRndInteger(-10, 10));
            }
            for (var i = 0; i < _right - 1; i++) {
                rightPoints.push(getRndInteger(-10, 10));
            }
            for (var i = 0; i < _top - 1; i++) {
                topPoints.push(getRndInteger(-10, 10));
            }
            for (var i = 0; i < _bottom - 1; i++) {
                bottomPoints.push(getRndInteger(-10, 10));
            }
            // working neg to pos
            leftPoints.sort(function (a, b) { return a - b });
            // working pos to neg
            rightPoints.sort(function (a, b) { return a - b });
            rightPoints.reverse();
            // working neg to pos
            topPoints.sort(function (a, b) { return a - b });
            // working pos to neg
            bottomPoints.sort(function (a, b) { return a - b });
            bottomPoints.reverse();

            allPoints = [];

            // put all the vertices in a list to easily reference. the 3rd vertex will always be the first vertex 
            // of the next triangle, and the generated origin will always be the second for each triangle.

            //start with the bottom left corner vertex
            allPoints.push([-12.5, -12.5, 0]);
            for (var i = 0; i < leftPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([-12.5, leftPoints[i], 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([-12.5, leftPoints[i], 0]);
            }
            //remove extra vertices and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            //finish the left triangles with the top left vertex
            allPoints.push([-12.5, 12.5, 0]);


            //next do the top vertices starting with the top left vertex
            allPoints.push([-12.5, 12.5, 0]);
            for (var i = 0; i < topPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([topPoints[i], 12.5, 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([topPoints[i], 12.5, 0]);
            }
            //remove extra vertex and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            //finish the top triangles with the top right vertex
            allPoints.push([12.5, 12.5, 0]);


            // next do the right vertices starting with the top right vertex
            allPoints.push([12.5, 12.5, 0]);
            for (var i = 0; i < rightPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([12.5, rightPoints[i], 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([12.5, rightPoints[i], 0]);
            }
            //remove extra vertex and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            //finish the right triangles with the bottom right vertex
            allPoints.push([12.5, -12.5, 0]);


            // lastly do the bottom vertices starting with the bottom right vertex
            allPoints.push([12.5, -12.5, 0]);
            for (var i = 0; i < bottomPoints.length + 1; i++) {
                // push origin point
                allPoints.push([centerx, centery, 0]);
                //push the next random vertex on the board line
                allPoints.push([bottomPoints[i], -12.5, 0]);
                // push the same point again as it will serve as the first vertex for the next triangle
                allPoints.push([bottomPoints[i], -12.5, 0]);
            }
            //remove extra vertex and replace with corner vertex
            allPoints.pop();
            allPoints.pop();
            // finish the bottom triangles with the bottom left vertex (initial starting vertex)
            allPoints.push([-12.5, -12.5, 0]);


            // turn the list of all the vertices into triangles!
            for (var i = 0; i < allPoints.length; i += 3) {
                tmpTriangle = new Triangle(allPoints[i], allPoints[i + 1], allPoints[i + 2]);
                tmpTriangle.render();
                triangles.push(tmpTriangle.mesh);
            }


        }



        buildBoard(13);
        /*
                t1 = new Triangle([-12.5, 12.5, 0], [centerx, centery, 0], [topx, 12.5, 0]);
                t1.render();
                triangles.push(t1.mesh);
                t2 = new Triangle([topx, 12.5, 0], [centerx, centery, 0], [12.5, 12.5, 0],);
                t2.render();
                triangles.push(t2.mesh);
                t3 = new Triangle([12.5, 12.5, 0], [centerx, centery, 0], [12.5, -12.5, 0],);
                t3.render();
                triangles.push(t3.mesh);
                t4 = new Triangle([12.5, -12.5, 0], [centerx, centery, 0], [bottomx, -12.5, 0],);
                t4.render();
                triangles.push(t4.mesh);
                t5 = new Triangle([bottomx, -12.5, 0], [centerx, centery, 0], [-12.5, -12.5, 0],);
                t5.render();
                triangles.push(t5.mesh);
                t6 = new Triangle([-12.5, -12.5, 0], [centerx, centery, 0], [-12.5, 12.5, 0],);
                t6.render();
                triangles.push(t6.mesh);
        */
        /*
                for (let i = 0; i < triangles.length - 1; i++) {
                    _out = triangles[i];
                    for (let j = 1; j < triangles.length; j++) {
                        _in = triangles[j];
                        outBB = new THREE.Box3().setFromObject(_out);
                        inBB = new THREE.Box3().setFromObject(_in);
                        collision = outBB.intersectsBox(inBB);
                        //while (collision) {
                        // }
                    }
                }
        */

        var controls = new THREE.DragControls(triangles, camera, renderer.domElement);
        controls.addEventListener('dragstart', function (event) {
            event.object.material.opacity = 0.7
        })
        controls.addEventListener('dragend', function (event) {
            event.object.material.opacity = 1
        })


    </script>
</body>

</html>